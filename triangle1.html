<!--
   Copyright (c) 2013-2023 Ossoey/experiments. 
   All rights reserved.
-->
<!-- About Us page for Ossoey segmentation website -->

<!-- Authored by ebanga@ossoey.com/ebanga@hotmail.com -->

<!DOCTYPE html> 
<html>
    <head>
        <title>Webgpu</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.4/css/all.css" integrity="sha384-DyZ88mC6Up2uqS4h/KRgHuoeGwBcD4Ng9SiP4dIRy0EXTlnuz47vAwmeGwVChigm" crossorigin="anonymous"/>       
        <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.16.8/xlsx.full.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.2.2/pdfmake.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.2.2/vfs_fonts.js"></script>
        
        <style>
            :root {

            --padding-right-left:20vw;   
            --header-padding:5px var(--padding-right-left);
            --padding-right-left-querymedia:2vw;  
            --header-padding-querymedia:5px var(--padding-right-left-querymedia);
            --header-margin: 0 2vh;

            --main-head-color: #505050de;
            --main-body--color: #ffffff;
            --main-font-family: Arial, Helvetica, sans-serif;
            --main-font-color: black;
            --main-line-color: rgba(0, 217, 255, 0.787);
            --main-padding:5px 10vw;

            --table-head-color:rgba(54, 37, 4, 0.787);
            --table-body-color1:rgba(0, 217, 255, 0.787);
            --table-alternate-color2:rgb(255, 209, 73);
            --table-font-family: Arial, Helvetica, sans-serif;
            --table-font-color:rgba(54, 37, 4, 0.787);
            
            --h1-font-size: 24px;
            --h2-font-size: 20px;
            } 

            *{
                margin: 0; 
                padding: 0;
                box-sizing: border-box;  
            }

            #header-id{
                padding:var( --header-padding);
            }

            #logo-menu-id{
                display: flex;
                justify-content: space-between;
            }

            #menu-button-id{
                cursor: pointer;
            }

            .menu-subbutton {
                width: 20px;
                height: 2px;
                background-color:var( --main-line-color); 
                margin: 2px;
            }

            nav{
                display: flex;
                justify-content: end;
            }

            #menu-id{
                position: absolute;
                top: 20px;
                right:var(--padding-right-left);
                display: none;
            }

            .nav-item{
                cursor: pointer;
                border: 2px var(--table-body-color1) solid;
                margin: 3px 0;
            }



            #main-id{
                display: flex;
                justify-content: center;
            }


            #home-id{
                padding:var( --header-padding);
             
            }

            .home-menu-item{
                cursor: pointer;
                margin: 3px 0;
                border: 2px var(--table-body-color1) solid;
            }






            .fielsetclass {
                border: none;
                margin-bottom: 20px;
                border-top: 2px var(--table-body-color1) solid;
            }

             legend {
                margin: 5px 0;
              
            }

            .containerinputframe{
                display: grid;
                grid-template-columns: repeat(3, 1fr); /* Three equal-sized columns */
                grid-gap: 3px; /* Adjust the gap between items */
              
            }

            .inputtext{
                padding: 4px 6px;
                margin: 0 8px;
            }

            .inputlabel{
              
                margin: 0 8px;
            }

            .containsubmitbutton{
                display: grid;
                grid-template-columns: repeat(3, 1fr); /* Three equal-sized columns */
                grid-gap: 3px; /* Adjust the gap between items */
              
            }

            .submitbutton{
                border: 2px var(--table-alternate-color2) solid;
                background-color: var(--main-head-color);
                cursor: pointer;
                padding: 5px 7px;
            }

            .table-striped tbody tr:nth-child(even) {
                background-color:var(--table-body-color1);
            }
            .table-striped tbody tr:nth-child(odd) {
                background-color:var(--table-alternate-color2);
            }


   


            #footer-id{
                padding:var( --header-padding);
            }

           @media (max-width:900px) {
                #header-id{
                    padding:var(    --header-padding-querymedia );
                }

                #menu-id{
 
                    right:var(--padding-right-left-querymedia);
 
                }

                #home-id{
                    padding:var(    --header-padding-querymedia );
                }

                #footer-id{
                    padding:var(  --header-padding-querymedia );
                }

                .containerinputframe{
                    display: block;
                }

           }         

        </style>

    </head>
    <body>

        <div id="header-id"> 

            <div id="logo-menu-id">
                <div id="logo-frame-id">
                    <div id="logo-id"> <h1>Webgpu</h1></div>
                    <div id="module-id"> <h2>Triangle 1</h2></div>
                    
                </div> 
                <div id="menu-button-id">
                    <div class="menu-subbutton"></div>
                    <div class="menu-subbutton"></div>
                    <div class="menu-subbutton"></div>
                </div>
            </div>
            <nav>
                <div id="menu-id">
                    <div class="nav-item">Vector addition</div>
                    <div class="nav-item">Dot product</div>
                    <div class="nav-item">Magnitude</div>
                    <div class="nav-item">Distance</div>  
                    <div class="nav-item"id="Compute-id"> <a href="compute.html">Compute</a></div>
                    <div class="nav-item" id="homepage-id"> <a href="index.html">Home</a></div>  
                </div>
            </nav>
        </div>

        <div id="main-id">

            <form id="vector-addition-id">
                
                <fieldset id="fieldsetinput-id" class="fielsetclass">
                    <legend><h4> Input &nbsp;</h4></legend>
                    <div class="containerinputframe" >
                              <div> <canvas> </canvas></div>
                    </div>
                </fieldset>

                <fieldset id="fieldsetsubmit-id" class="fielsetclass">
                    <legend> <h4> Submit  &nbsp;</h4></legend>
                    <div  class="containsubmitbutton">
                        <button class="submitbutton" id="run">Run</button>
        
                        <button class="submitbutton" id="clear">Clear</button>    
                    </div>
                </fieldset>

                <fieldset id="fieldsetresult-id" class="fielsetclass">
                    <legend><h4> Output  &nbsp; </h4></legend>
                    <div  id="tableframe-id">
                        <table  class="table-striped">
                          <thead>
                            <tr>
                              <th>Column 1</th>
                              <th>Column 2</th>
                              <th>Column 3</th>
                            </tr>
                          </thead>
                          <tbody>
                            <tr>
                              <td>Row 1, Column 1</td>
                              <td>Row 1, Column 2</td>
                              <td>Row 1, Column 3</td>
                            </tr>
                            <tr>
                              <td>Row 2, Column 1</td>
                              <td>Row 2, Column 2</td>
                              <td>Row 2, Column 3</td>
                            </tr>
                          </tbody>
                        </table>
                    </div>
                </fieldset>


               
            </form>

        </div>
        
        <div id="footer-id">
            <h3> webgpu.Ossoey.com &#169;Copyright 2023 </h3>
        </div>  

        <script  type="module" >
             const menu_button = document.getElementById('menu-button-id');
             const menu_id = document.getElementById('menu-id');

             menu_button.addEventListener('click', () => {
             if (menu_id.style.display === 'block') {
                 menu_id.style.display = 'none'; // Hide the element
             } else {
                
                 menu_id.style.display = 'block'; // Display the element
             }
             });

            // const run = document.getElementById('run');

            // run.addEventListener('click', () => {
     
            // });


             // wgsl language
             // type
  


        async function mainTriangleHardCoded(){

            //Configuration d'objet(Materiel) de traitement et d'affichage
            const adapter = await navigator.gpu.requestAdapter();
            if(!adapter){
                alert(`This navigator doesn't support webgpu`);
                return;
            }

            const device = await adapter.requestDevice();
            if(!device){
                alert(`Not able to request device`);
                return
            }

            const canvas = document.querySelector(`canvas`);
            const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
            const context = canvas.getContext(`webgpu`);
            context.configure({
                device, 
                format:canvasFormat
            });

            // Configuration de shader et de pipeline

            const shaderModule = device.createShaderModule({
                label: `Shader for Hardecode Triangle`,
                code: `
                    @vertex fn vs(@builtin(vertex_index) vertexIndex : u32)-> @builtin(position) vec4f{
                        var pos= array(
                            vec2f(0,-0.5),
                            vec2f(-0.5,0),
                            vec2f(0.5,0)
                        );
                        return vec4f(pos[vertexIndex],0,1);
                    }

                    @fragment fn fs()->@location(0) vec4f{
                        return vec4f(0,1,0,1);
                    }
                `
            });

            const pipeline = device.createRenderPipeline({
                label: `Pipeline For hardcode triangle `,
                layout: `auto`,
                vertex: {
                    entryPoint: `vs`,
                    module: shaderModule,
                },

                fragment: {
                    entryPoint: `fs`,
                    module: shaderModule,
                    targets: [{format : canvasFormat}]
                }

            });

            const renderPassDescriptor = {
                label: `renderPass descriptor triangle Hardcoded`,
            
                
                colorAttachments:[{
                    view: context.getCurrentTexture().createView(),
                    clearValue: [0.3, 0.3, 0.3, 1],
                    loadOp: 'clear',
                    storeOp: 'store',


                    
                }]  
            }

            function render(){
                const cmdEncoder = device.createCommandEncoder({
                    label: `cmdEncoder HardCoded Triangle`
                });

                const pass = cmdEncoder.beginRenderPass(renderPassDescriptor);
                                        
                pass.setPipeline(pipeline);
                pass.draw(3);
                pass.end();

                device.queue.submit([cmdEncoder.finish()]);

            }

            render();


        }

        async function interChangedColor(){
            //Configuration d'objet(Materiel) de traitement et d'affichage
             const adapter = await navigator.gpu.requestAdapter();
            if(!adapter){
                alert(`This navigator doesn't support webgpu`);
                return;
            }

            const device = await adapter.requestDevice();
            if(!device){
                alert(`Not able to request device`);
                return
            }

            const canvas = document.querySelector(`canvas`);
            const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
            const context = canvas.getContext(`webgpu`);
            context.configure({
                device, 
                format:canvasFormat
            });

            // Configuration de shader et de pipeline

            const shaderModule = device.createShaderModule({
                label: `Shader for Hardecode Triangle`,
                code: `

                    struct OutputElement{
                        @builtin(position) position :vec4f,
                        @location(0) color : vec4f,
                        @location(1) @interpolate(flat) vertexIndex : u32
                    };

                    @vertex fn vs(@builtin(vertex_index) vertexIndex : u32)-> OutputElement{
                       
                        var pos = array(
                            vec2f(0,0.5),
                            vec2f(-0.5,0),
                            vec2f(0.5,0)
                        );

                        var color = array (
                            vec4f(1.,0,0,1),
                            vec4f(0,1,0,1),
                            vec4f(0,0,1,1)
                        );

                        var output : OutputElement; 
                        output.position=  vec4f(pos[vertexIndex],0,1) ;
                        output.color = color[vertexIndex];
                        return output;
                    }

                    @fragment fn fs(input: OutputElement)->@location(0) vec4f{
                        return input.color;
                    }
                `
            });

            const pipeline = device.createRenderPipeline({
                label: `Pipeline For hardcode triangle `,
                layout: `auto`,
                vertex: {
                    entryPoint: `vs`,
                    module: shaderModule,
                },

                fragment: {
                    entryPoint: `fs`,
                    module: shaderModule,
                    targets: [{format : canvasFormat}]
                }

            });

            const renderPassDescriptor = {
                label: `renderPass descriptor triangle Hardcoded`,
            
                
                colorAttachments:[{
                    view: context.getCurrentTexture().createView(),
                    clearValue: [0.3, 0.3, 0.3, 1],
                    loadOp: 'clear',
                    storeOp: 'store',
                    
                }]  
            }

            function render(){
                const cmdEncoder = device.createCommandEncoder({
                    label: `cmdEncoder HardCoded Triangle`
                });

                const pass = cmdEncoder.beginRenderPass(renderPassDescriptor);
                                        
                pass.setPipeline(pipeline);
                pass.draw(3);
                pass.end();

                device.queue.submit([cmdEncoder.finish()]);

            }

            render();

        }


        async function interChangedPosition(){
            //Configuration d'objet(Materiel) de traitement et d'affichage
             const adapter = await navigator.gpu.requestAdapter();
            if(!adapter){
                alert(`This navigator doesn't support webgpu`);
                return;
            }

            const device = await adapter.requestDevice();
            if(!device){
                alert(`Not able to request device`);
                return
            }

            const canvas = document.querySelector(`canvas`);
            const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
            const context = canvas.getContext(`webgpu`);
            context.configure({
                device, 
                format:canvasFormat
            });

            // Configuration de shader et de pipeline

            const shaderModule = device.createShaderModule({
                label: `Shader for Hardecode Triangle`,
                code: `

                    struct OutputElement{
                        @builtin(position) position :vec4f,
                        @location(0) color : vec4f,
                        @location(1) @interpolate(flat) vertexIndex : u32
                    };

                    struct Rect{
                        color: vec4f, 
                        isFilled: bool
                    };

                    // offset move spot, tex is texture
                    fn rect(offset_x:f32,offset_y:f32 ,width_x:f32,width_y:f32,text_x:f32,text_y:f32,colorFore:vec4f)->Rect{
                
                        var output: Rect;
                        if((text_x>0+offset_x)&& (text_x<width_x+offset_x))&&
                        ((text_y>0+offset_y)&& (text_y<width_y+offset_y)){
                            output.isFilled = true;  
                            output.color = colorFore;
                        } else{
                            output.isFilled = false;  
                        }
                        
                        return output;
                    }

                    @vertex fn vs(@builtin(vertex_index) vertexIndex : u32)-> OutputElement{
                       
                        var pos = array(
                            vec2f(0,1),
                            vec2f(-1,-0.75),
                            vec2f(1,-0.75)
                        );

                        var color = array (
                            vec4f(1.,0,0,1),
                            vec4f(0,1,0,1),
                            vec4f(0,0,1,1)
                        );

                        var output : OutputElement; 
                        output.position=  vec4f(pos[vertexIndex],0,1) ;
                        output.color = color[vertexIndex];
                        return output;
                    }


        
                    @fragment fn fs(input: OutputElement)->@location(0) vec4f{
                        var pos = input.position;
                        var result = vec4f(1,0,1,0);

                        var  spot = rect(150,50,3,3,pos.x,pos.y,vec4f(1,1,1,0));
                        if (spot.isFilled == true) {
                            result = spot.color;
                        }  

                                    
                        return  result;
                    }
                `
            });

            const pipeline = device.createRenderPipeline({
                label: `Pipeline For hardcode triangle `,
                layout: `auto`,
                vertex: {
                    entryPoint: `vs`,
                    module: shaderModule,
                },

                fragment: {
                    entryPoint: `fs`,
                    module: shaderModule,
                    targets: [{format : canvasFormat}]
                }

            });

            const renderPassDescriptor = {
                label: `renderPass descriptor triangle Hardcoded`,
            
                
                colorAttachments:[{
                    view: context.getCurrentTexture().createView(),
                    clearValue: [0.3, 0.3, 0.3, 1],
                    loadOp: 'clear',
                    storeOp: 'store',


                    
                }]  
            }

            function render(){
                const cmdEncoder = device.createCommandEncoder({
                    label: `cmdEncoder HardCoded Triangle`
                });

                const pass = cmdEncoder.beginRenderPass(renderPassDescriptor);
                                        
                pass.setPipeline(pipeline);
                pass.draw(3);
                pass.end();

                device.queue.submit([cmdEncoder.finish()]);

            }

            render();

        }


        
        async function interChangedSpot(){
            //Configuration d'objet(Materiel) de traitement et d'affichage
             const adapter = await navigator.gpu.requestAdapter();
            if(!adapter){
                alert(`This navigator doesn't support webgpu`);
                return;
            }

            const device = await adapter.requestDevice();
            if(!device){
                alert(`Not able to request device`);
                return
            }

            const canvas = document.querySelector(`canvas`);
            const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
            const context = canvas.getContext(`webgpu`);
            context.configure({
                device, 
                format:canvasFormat
            });

            // Configuration de shader et de pipeline

            const shaderModule = device.createShaderModule({
                label: `Shader for Hardecode Triangle`,
                code: `

                    struct OutputElement{
                        @builtin(position) position :vec4f,
                        @location(0) color : vec4f,
                        @location(1) @interpolate(flat) vertexIndex : u32
                    };

                    struct Rect{
                        color: vec4f, 
                        isFilled: bool
                    };

                    struct RecCoords {
                        offset_x:f32,offset_y:f32 ,width_x:f32,width_y:f32,text_x:f32,text_y:f32
                    }

                    // offset move spot, tex is texture
                    fn rect(offset_x:f32,offset_y:f32 ,width_x:f32,width_y:f32,text_x:f32,text_y:f32,colorFore:vec4f)->Rect{
                
                        var output: Rect;
                        if((text_x>0+offset_x)&& (text_x<width_x+offset_x))&&
                        ((text_y>0+offset_y)&& (text_y<width_y+offset_y)){
                            output.isFilled = true;  
                            output.color = colorFore;
                        } else{
                            output.isFilled = false;  
                        }
                        
                        return output;
                    }


                    
                    struct ParamsSimpleRect{
                        offset_x:f32,
                        offset_y:f32 ,
                        width_x:f32,
                        width_y:f32,
                        text_x:f32,
                        text_y:f32,
                        color:vec4f, 
                        isFilled: bool
                    }; 

                    // offset move spot, tex is texture
                    fn simple_rect(params:ParamsSimpleRect)->ParamsSimpleRect{
                
                        var output: ParamsSimpleRect;
                        if((params.text_x>0+params.offset_x)&& (params.text_x<params.width_x+params.offset_x))&&
                        ((params.text_y>0+params.offset_y)&& (params.text_y<params.width_y+params.offset_y)){
                            output.isFilled = true;  
                            output.color = params.color;
                        } else{
                            output.isFilled = false;  
                        }
                        
                        return output;
                    }



                    fn foo(p : ptr<function, i32>) -> i32 {
                        let x = *p;
                        *p += 1;
                        return x;
                    }


                    var<private> modf: f32 = 0.0;

                    fn block(color:ptr<function, vec4f>,  ){

                
                
                    }

                    @vertex fn vs(@builtin(vertex_index) vertexIndex : u32)-> OutputElement{
                       
                        var pos = array(
                            vec2f(0,1),
                            vec2f(-1,-0.75),
                            vec2f(1,-0.75)
                        );

                        var color = array (
                            vec4f(1.,0,0,1),
                            vec4f(0,1,0,1),
                            vec4f(0,0,1,1)
                        );

                        var output : OutputElement; 
                        output.position=  vec4f(pos[vertexIndex],0,1) ;
                        output.color = color[vertexIndex];
                        return output;
                    }


        
                    @fragment fn fs(input: OutputElement)->@location(0) vec4f{
                        var pos = input.position;
                        var result = vec4f(1,0,1,0);
                        
                        var rp : ParamsSimpleRect;
                        //offset_x:f32,offset_y:f32 ,width_x:f32,width_y:f32,text_x:f32,text_y 
                        rp.offset_x = 150;
                        rp.offset_y = 50;
                        rp.width_x = 5;
                        rp.width_y = 10;
                        rp.text_x = pos.x;
                        rp.text_y = pos.y;
                        rp.color = vec4f(1,1,0,1);
                        var move_offset_x:f32;
                        
                       /*
                        var  spot = rect(rp.offset_x,rp.offset_y,rp.width_x ,rp.width_y,pos.x,pos.y,vec4f(1,1,1,0));
                        if (spot.isFilled == true) {
                            result = spot.color;
                        }  

                       
                        for (var i = 0; i<20; i=i+1 ) 
                        {
                            spot = rect(rp.offset_x+ move_offset_x ,rp.offset_y,rp.width_x ,rp.width_y,pos.x,pos.y,vec4f(1,1,1,0));

                            if (spot.isFilled == true) {
                                result = spot.color;
                            
                            }  

                            move_offset_x = move_offset_x+ rp.width_x;
                        
                        } 
                         */
                       
                        var  spot = simple_rect(rp);
                        if (spot.isFilled == true) {
                            result = spot.color;
                        }  

                       
                        for (var i = 0; i<20; i=i+1 ) 
                        {

                            rp.offset_x =  move_offset_x ;
                            rp.offset_y = rp.offset_y;
                             rp.width_x  = rp.width_x;
                            // rp.width_y  = rp.width_y;
                           // rp.width_x = 1;
                            rp.width_y = 10;

                            rp.text_x   = pos.x;
                            rp.text_y   = pos.y;
                            rp.color    = vec4f(1,1,0,1);
                            
                            spot = simple_rect(rp);

                            if (spot.isFilled == true) {
                                result = spot.color;
                            
                            }  

                            move_offset_x = move_offset_x+ rp.width_x;
                        
                        } 
                     
         
                   
                                    
                        return  result;
                    }
                `
            });

            const pipeline = device.createRenderPipeline({
                label: `Pipeline For hardcode triangle `,
                layout: `auto`,
                vertex: {
                    entryPoint: `vs`,
                    module: shaderModule,
                },

                fragment: {
                    entryPoint: `fs`,
                    module: shaderModule,
                    targets: [{format : canvasFormat}]
                }

            });

            const renderPassDescriptor = {
                label: `renderPass descriptor triangle Hardcoded`,
            
                
                colorAttachments:[{
                    view: context.getCurrentTexture().createView(),
                    clearValue: [0.3, 0.3, 0.3, 1],
                    loadOp: 'clear',
                    storeOp: 'store',


                    
                }]  
            }

            function render(){
                const cmdEncoder = device.createCommandEncoder({
                    label: `cmdEncoder HardCoded Triangle`
                });

                const pass = cmdEncoder.beginRenderPass(renderPassDescriptor);
                                        
                pass.setPipeline(pipeline);
                pass.draw(3);
                pass.end();

                device.queue.submit([cmdEncoder.finish()]);

            }

            render();

        }



        async function computer(){

            const adapter = await navigator.gpu.requestAdapter();
            if(!adapter){
                alert(`This navigator doesn't support webgpu`);
                return;
            }

            const device = await adapter.requestDevice();
            if(!device){
                alert(`Not able to request device`);
                return
            }

        }

        async function main(){
           // mainTriangleHardCoded();
           // interChangedColor();
           // interChangedPosition();
            
            interChangedSpot()
            // computer();
        }

        await main();


        </script>

    </body>

</html>